// ////////////////////////////////////////////////////////////////////////////
//
// ////////////////////////////////////////////////////////////////////////////
#ifndef QXPACK_IC_ALGOR_PEAK_HPP
#define QXPACK_IC_ALGOR_PEAK_HPP

#include <cstdint>
#include <type_traits>
#include <utility>
#include <functional>

#include "qxpack_ic_algor_base.hpp"

#ifndef QXPACK_IC_CXX11
#if __cplusplus >= 201103L || ( defined(_MSC_VER) && _MSC_VER >= 1800 )
#  define QXPACK_IC_CXX11
#else
#  error "this template require C++11 !"
#endif
#endif

namespace QxPack {
namespace IcAlgor {

// ////////////////////////////////////////////////////////////////////////////
// : API list
// ----------------------------------------------------------------------------
//
// makePeakAry  -- for Peak algorithm, this is used to generate the inter data
// findNextPeak -- you know what it is by name...
//
// ////////////////////////////////////////////////////////////////////////////

// ============================================================================
// make peak array
// ============================================================================
//! @param  s  [in ]  the source array that used to calc.
//! @param  c  [out]  the peak array used to store the peak information
//! @param  n  [in ]  the size of source array ( also peak array )
//! @return true means make array succ.
//! @details his routine find all corner point in array. \n
//!   1   3 3 2 4   5   ==> will make
//!  [2] -2 0 2 0 [-2]
template <typename T >
auto     makePeakAry ( const T *s, int8_t *c, size_t n ) -> bool
{
    static_assert( std::is_pod<T>::value, "T should be POD type!" );
    if ( n < 1 ) { return false; }

    // generate the difference array
    {
        auto x  = n - 1;
        auto s1 = s;    auto s2 = s + 1;
        auto d  = c + 1;

        while ( x -- > 0 ) {
           if      ( *s2 > *s1 ) { *d ++ =  1; }
           else if ( *s2 < *s1 ) { *d ++ = -1; }
           else    { *d ++ =  0; }
           ++ s1; ++ s2;
        }
        *c = 0; /* fill the first element */
    }

    // fix. from tail to head
    {
        auto x = n - 1; auto r = c + n - 2;
        while ( x -- > 0 ) {       
            // skip if not zero
            if ( *r != 0 ) { -- r; continue; }
            r[0] = r[1]; -- r;
        }
    }

    // final calc.
    {
        auto x = n - 2;
        auto r1 = c + 1; auto r2 = c + 2;
        while ( x -- > 0 ) { *r1 = ( *r2 ++ ) - *r1; ++ r1;}
        c[0] = 0; c[ n - 1 ] = 0;
    }

    // sequence fixs
    {
        size_t x; int8_t *src;

        /* head fix */
        x = n; src = c;  while ( x > 0  &&  *src == 0 ) { ++ src; -- x; }
        if ( x > 0 ) {
            if      ( *src ==  2 ) { *c = -2; }
            else if ( *src == -2 ) { *c =  2; }
            else { ; }
        }

        /* tail fix */
        x = n; src = c + n - 1; while ( x > 0  && *src == 0 ) { -- src; -- x; }
        if ( x > 0 ) {
            if      ( *src ==  1 ) { *src =  2; }
            else if ( *src == -1 ) { *src = -2; }
            else {
                if ( src != c + n - 1 ) {
                    if ( *src == 2 ) { c[n-1] = -2; } else { c[n-1] = 2; }
                }
            }
        }
   }

   return true;
}

// ============================================================================
// find next peak descr by peak array
// ============================================================================
struct PeakDescr {
    size_t begin, middle, end; bool is_mid_need_add_pt5, is_valid;
    PeakDescr()
    { begin = middle = end = 0; is_mid_need_add_pt5 = false; is_valid = false; }
};

//! @param  s  [in]  the source array
//! @param  p  [in]  peak array that generated by makePeakAry
//! @param  n  [in]  the peak array length ( also source array length )
//! @param  b  [in_out]  the begin position for current position.
template <typename T>
auto     findNextPeak( const T *s, const int8_t *p, size_t n, size_t &b ) -> PeakDescr
{
    static_assert( std::is_pod<T>::value, "T should be POD type!" );

    // find a peak
    PeakDescr peak; bool ret = true;
    {
        auto limit = p +  n;
        auto curr  = p +  b;
        while ( curr < limit  &&  *curr !=  2 ) { ++ curr; }
        if ( curr < limit ) { peak.begin = size_t(( curr ++ ) - p ); } else { ret = false; }
        while ( curr < limit  &&  *curr != -2 ) { ++ curr; }
        if ( curr < limit ) { peak.middle= size_t(( curr ++ ) - p ); } else { ret = false; }
        while ( curr < limit  &&  *curr !=  2 ) { ++ curr; }
        if ( curr < limit ) { peak.end   = size_t(( curr ++ ) - p ); } else { ret = false; }
    }
    if ( ! ret ) { peak.is_valid = false; return peak; } // no peak

    // update the begin index
    b = peak.end;

    // adjust the peak middle, make it average
    {
        auto org_mid_val = s[ peak.middle ];
        auto right = s + peak.middle;
        auto limit = s + peak.end;
        while ( right < limit  &&  fuzzyCompare( org_mid_val, *right )) { ++ right; }
        auto left  = s + peak.middle;
        limit = s + peak.begin;
        while ( left  > limit  &&  fuzzyCompare( org_mid_val, *left  )) { -- left; }
        peak.is_mid_need_add_pt5 = ( (( right - left ) % 2 ) != 0 ? true : false );
        peak.middle = size_t(( right - left ) / 2 + left - s ); // ? this is bad ???
    }

    // ----------------------------------------------------------------------------
    // adjust the peak left/right
    // Rule: 1) the left  point is always locate  BEFORE the first changed data
    //       2) the right point is always locate the first smooth/lowest data after the middle data
    //       0 0 1 2 3 3 3 2 1 0 0  is locate  0 [0] 1 2 3 [3] 3 2 1 [0] 0
    // ----------------------------------------------------------------------------
    {
        auto org_bg_val = s[ peak.begin ];
        auto curr  = s + peak.begin;
        auto limit = s + peak.middle;
        while ( curr < limit  &&  fuzzyCompare( org_bg_val, *curr )) { ++ curr; }
        if ( curr > s + peak.begin ) { peak.begin = size_t( curr - s - 1 ); } // since 20210301-1640 fixed

        auto org_end_val = s[ peak.end ];
        curr  = s + peak.end;
        limit = s + peak.middle;
        while ( curr > limit  &&  fuzzyCompare( org_end_val, *curr )) { -- curr; }
        if ( curr < s + peak.end ) { peak.end = size_t( curr - s + 1 ); }
    }

    peak.is_valid = true;
    return peak;
}

}
}

#endif
